# DATA JPA
* [CRUD](#crud)
* [Generators](#generators)
* [Data Finder Methods](#data-finder-methods)

## CRUD
Data JPA provides **CrudRepository** for CRUD operations

```
public interface ProductRepo extends CrudRepository<Product,Integer> {
}
```

  * Save - productRepo.save(product)
  * Save List - productRepo.save(productList)          
  * find - productRepo.findById(1)
  * update - productRepo.save(1)
       product = productRepo.findById(1)
       product.setName("new name")
       productRepo.findById(product)
  * delete - productRepo.deleteById(1)
  * isExist - productRepo.existsById(1)
  * COUNT - productRepo.count()
  
## Generators
### [IDENTITY STATERGY](crud/crud-data-jpa)
This type of generation relies on the IdentityGenerator which expects values generated by an **identity column in the database**, meaning they are **auto-incremented**.
```
@Entity
public class Product {
    #create table product( id int NOT NULL AUTO_INCREMENT,name varchar(20),description varchar(100),price decimal(8,3) , CONSTRAINT id_pk PRIMARY KEY (id));
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    private Integer id;   
}
```

### [TABLE STATERGY](id-genertion-statergy/idgenerator-table)
The TableGenerator uses an underlying **database table** that holds segments of identifier generation values.
```
@Entity
public class Employee {

    //create table id_gen(gen_name varchar(60) PRIMARY KEY,gen_val int(20))
    @TableGenerator(name = "emp_pk_generator",table = "id_gen",pkColumnName = "gen_name",valueColumnName ="gen_val",allocationSize = 1)
    
    @GeneratedValue(strategy = GenerationType.TABLE,generator = "emp_pk_generator")
    @Id
    private Integer id; 
}
```
### [CUSTOM STATERGY](id-genertion-statergy/idgenerator-custom)
If we don't want to use any of the out-of-the-box strategies,**we can define our custom generator by implementing the IdentifierGenerator interface**.
```
public class CustomItomPrimaryKeyGenerator implements IdentifierGenerator {
    @Override
    public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException {
        //Logic
        return id;
    }
}

@Entity
public class Item {
    @GenericGenerator(name = "emp_pk_generator",strategy = "CustomItomPrimaryKeyGenerator")
    @GeneratedValue(generator = "emp_pk_generator")
    @Id
    private Integer id; 
}

```
##  [Data Finder Methods](data-finder-methods)
Spring Data Jpa not only provides implementation for commonly used methods but also provides a way to add custom methods. The method signature tells Spring Data Jpa everything it needs to know in order to create an implementation for the method. Spring Data Jpa defines a sort of **domain-specific language (DSL)** where persistence details are expressed in **method signatures**

```
public interface ProductRepo extends CrudRepository<Product,Integer> {
    List<Product> findByProductName(String name);
    List<Product> findByProductNameAndPrice(String name,Double price);
    List<Product> findByPriceGreaterThan(Double price);
    List<Product> findByDescriptionContains(String searchString);
    List<Product> findByProductNameLike(String name);
    List<Product> findByPriceBetween(Double minmum,Double maximum);
    List<Product> findByPriceIn(List<Double> priceList);
}

```
##  [Paging and Sorting](paging-sorting)
**PagingAndSortingRepository** extends **CrudRepo** and provides additional paging and shorting features.
```
public interface ProductRepo extends PagingAndSortingRepository<Product,Integer> {}

@SpringBootTest
class PagingAndShortingApplicationTests {

	@Autowired
	ProductRepo productRepo;

	@Test
	void contextLoads() {
	}

	@Test
	void testPaging(){
		System.out.println("testPaging START **********");
		Pageable pageable = PageRequest.of(0,2);
		productRepo.findAll(pageable).forEach(System.out::println);
		System.out.println("testPaging END **********");
	}

	@Test
	void testSorting(){
		System.out.println("testSorting START **********");
		productRepo.findAll(Sort.by(Sort.Direction.DESC,"productName")).forEach(System.out::println);
		System.out.println("testSorting END **********");
	}

	@Test
	void testSortByMultipeProperties(){
		System.out.println("testSortByMultipeProperties START **********");
		productRepo.findAll(Sort.by(Sort.Direction.DESC,"productName","price")).forEach(System.out::println);
		System.out.println("testSortByMultipeProperties END **********");
	}

	@Test
	void testSortByMultipePropertiesAndMultipleDirection(){
		System.out.println("testSortByMultipePropertiesAndMultipleDirection START **********");
		productRepo.findAll(Sort.by(Sort.Order.asc("productName"), Sort.Order.desc("price"))).forEach(System.out::println);
		System.out.println("testSortByMultipePropertiesAndMultipleDirection END **********");
	}

	@Test
	void testPagingAndSorting(){
		System.out.println("testPagingAndSorting START **********");
		System.out.println("PAGE 1");
		Pageable pageable = PageRequest.of(0,3,Sort.by(Sort.Order.asc("productName"), Sort.Order.desc("price")));
		productRepo.findAll(pageable).forEach(System.out::println);
		System.out.println("PAGE 2");
		pageable = PageRequest.of(1,3,Sort.by(Sort.Order.asc("productName"), Sort.Order.desc("price")));
		productRepo.findAll(pageable).forEach(System.out::println);
		System.out.println("testPagingAndSorting END **********");
	}

	@Test
	void testCustomFinderPagingAndSorting(){
		System.out.println("testCustomFinderPagingAndSorting START **********");
		System.out.println("PAGE 1");
		Pageable pageable = PageRequest.of(0,3,Sort.by(Sort.Order.asc("productName"), Sort.Order.desc("price")));
		productRepo.findByPriceGreaterThan(8000d,pageable).forEach(System.out::println);
		System.out.println("PAGE 2");
		pageable = PageRequest.of(1,3,Sort.by(Sort.Order.asc("productName"), Sort.Order.desc("price")));
		productRepo.findByPriceGreaterThan(8000d,pageable).forEach(System.out::println);
		System.out.println("testCustomFinderPagingAndSorting END **********");
	}
}
```
**Paging and Sorting for Custom Finder Methods** <br>
Add **Pageable** as parameter to CustomFinder Method to enable paging and soring
```
List<Product> findByPriceGreaterThan(Double price, Pageable pageable);
```

##  [JPQA](jpql)
Java Persistance Query Language.
* Entity Class Name and Field Names are case sensitive
* Key words (select,like) not case sensitive
* You just need to Define method and JPQL no implementation required
* Use **@Query** to write JPQL query
* Use **@Param** to map method parameter to named param in Query
* Use **@Modifying** for DML , otherwise spring throws exception

**Code Snipt**
```
public interface StudentRepo  extends CrudRepository<Student,Integer> {
    //IF YOU SELECT ALL THE COLUMN THEN IT GIVES STUDENT OBJECT OTHERWISE OBJECT ARRAY
    @Query("from Student")
    List<Student> getAllStudents();

    @Query("select firstName,lastName,score from Student")
    List<Object[]> getAllStudentsPartialData();

    //NAMED QUERY
    @Query("from Student where lastName=:lstName")
    List<Student> getAllStudentsWithLastName(@Param("lstName") String lastName);

    @Query("from Student where score>:minScore and score<:maxScore")
    List<Student> getAllStudentsBetweenScoreRange(@Param("minScore") Integer min,@Param("maxScore") Integer max);

    //NON SELECT OPERATION NEEDS @Modifying annotation, with out this spring wont consider it as DML and through exception
    @Modifying
    @Query("delete from Student where lastName=:lsName")
    void deleteStudentByLastName(@Param("lsName") String lastName);
}

@SpringBootTest
class JpqlAndNativeSqlApplicationTests {

	@Autowired
	StudentRepo studentRepo;	 

	@Test
	void testGetAllStudents(){
		System.out.println("************ testGetAllStudents START ************");
		studentRepo.getAllStudents().forEach(System.out::println);
		System.out.println("************ testGetAllStudents END ************");
	}

	@Test
	void getAllStudentsPartialData(){
		System.out.println("************ getAllStudentsPartialData START ************");
		studentRepo.getAllStudentsPartialData().forEach(student-> System.out.println(student[0]+" "+student[1]+" "+student[2]));
		System.out.println("************ getAllStudentsPartialData END ************");
	}
	 
	@Test
	void getAllStudentsBetweenScoreRange(){
		System.out.println("************ getAllStudentsBetweenScoreRange START ************");
		studentRepo.getAllStudentsBetweenScoreRange(80,95).forEach(System.out::println);
		System.out.println("************ getAllStudentsBetweenScoreRange END ************");
	}

	@Test
	@Transactional //TO RUN DML
	//@Rollback(false) //IN TEST SPRING REVERTS ALL DML OPERATION AFTER THE EXECUTION,IF YOU WANT TO REALY DELETE DATA THEN USE ROLLBACK FALSE
	void testdeleteStudentByLastName(){
		System.out.println("************ deleteStudentByLastName START ************");
		studentRepo.deleteStudentByLastName("ASHOK");
		System.out.println("************ deleteStudentByLastName END ************");
	}
}

```
**Paging and Sorting for Custom Finder Methods** <br>
Add **Pageable** as parameter to CustomFinder Method to enable paging and soring
```
@Query("from Student")
List<Student> getAllStudentsWithPagingAndSorting(Pageable pageable);

@Test
void getAllStudentsWithPagingAndSorting(){
	System.out.println("************ getAllStudentsWithPagingAndSorting START ************");
	System.out.println("PAGE 1");
	Pageable pageable = PageRequest.of(0,3,Sort.by(Sort.Order.desc("score"),Sort.Order.asc("firstName")));
	studentRepo.getAllStudentsWithPagingAndSorting(pageable).forEach(System.out::println);

	System.out.println("PAGE 2");
	pageable = PageRequest.of(1,3,Sort.by(Sort.Order.desc("score"),Sort.Order.asc("firstName")));
	studentRepo.getAllStudentsWithPagingAndSorting(pageable).forEach(System.out::println);

	System.out.println("************ getAllStudentsWithPagingAndSorting END ************");
}
```
 ## 11.HIBERNATE MAPPINGS    
8.NATIVE SQL 9.INHERITANCE MAPPING 10.COMPONENET MAPPING  11.HIBERNATE MAPPINGS 12.HIBERNATE CACHING 13.TRANSACTION MANAGEMENT
